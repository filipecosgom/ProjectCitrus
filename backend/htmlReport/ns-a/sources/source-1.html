


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AppraisalService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">pt.uc.dei.services</a>
</div>

<h1>Coverage Summary for Class: AppraisalService (pt.uc.dei.services)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AppraisalService</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    45.8%
  </span>
  <span class="absValue">
    (11/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21.2%
  </span>
  <span class="absValue">
    (14/66)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    30.5%
  </span>
  <span class="absValue">
    (62/203)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package pt.uc.dei.services;
&nbsp;
&nbsp;import jakarta.ejb.EJB;
&nbsp;import jakarta.ejb.Stateless;
&nbsp;import jakarta.inject.Inject;
&nbsp;import jakarta.transaction.Transactional;
&nbsp;import jakarta.ws.rs.core.StreamingOutput;
&nbsp;
&nbsp;import org.apache.logging.log4j.LogManager;
&nbsp;import org.apache.logging.log4j.Logger;
&nbsp;import pt.uc.dei.dtos.*;
&nbsp;import pt.uc.dei.entities.AppraisalEntity;
&nbsp;import pt.uc.dei.entities.UserEntity;
&nbsp;import pt.uc.dei.enums.*;
&nbsp;import pt.uc.dei.entities.CycleEntity;
&nbsp;import pt.uc.dei.repositories.CycleRepository;
&nbsp;import pt.uc.dei.repositories.AppraisalRepository;
&nbsp;import pt.uc.dei.repositories.UserRepository;
&nbsp;import pt.uc.dei.utils.PdfGenerator;
&nbsp;import pt.uc.dei.mapper.AppraisalMapper;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.time.LocalDate;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;/**
&nbsp; * Service class for managing appraisal-related operations.
&nbsp; * &lt;p&gt;
&nbsp; * Provides functionality for appraisal creation, retrieval, updating,
&nbsp; * and filtering. Handles business logic and validation rules.
&nbsp; *
&nbsp; * @Stateless Marks this class as a stateless EJB, making it eligible for dependency injection
&nbsp; * and transaction management by the EJB container.
&nbsp; */
&nbsp;
&nbsp;/**
&nbsp; * Service class for managing appraisal-related operations.
&nbsp; * &lt;p&gt;
&nbsp; * Provides functionality for appraisal creation, retrieval, updating, and filtering.
&nbsp; * Handles business logic and validation rules.
&nbsp; *
&nbsp; * @Stateless Marks this class as a stateless EJB, making it eligible for dependency injection
&nbsp; * and transaction management by the EJB container.
&nbsp; */
&nbsp;@Stateless
<b class="fc">&nbsp;public class AppraisalService implements Serializable {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Logger instance for logging operations within this class.
&nbsp;     */
<b class="fc">&nbsp;    private static final Logger LOGGER = LogManager.getLogger(AppraisalService.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Serial version UID for serialization support.
&nbsp;     */
&nbsp;    private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;    @EJB
&nbsp;    private AppraisalRepository appraisalRepository;
&nbsp;
&nbsp;    @EJB
&nbsp;    private UserRepository userRepository;
&nbsp;
&nbsp;    @EJB
&nbsp;    private CycleRepository cycleRepository;
&nbsp;
&nbsp;    @Inject
&nbsp;    private AppraisalMapper appraisalMapper;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new appraisal.
&nbsp;     *
&nbsp;     * @param createAppraisalDTO The DTO containing appraisal creation data
&nbsp;     * @return The created appraisal DTO
&nbsp;     * @throws IllegalArgumentException If validation fails
&nbsp;     * @throws IllegalStateException    If business rules are violated
&nbsp;     */
&nbsp;    /**
&nbsp;     * Creates a new appraisal.
&nbsp;     *
&nbsp;     * @param createAppraisalDTO The DTO containing appraisal creation data
&nbsp;     * @return The created appraisal DTO
&nbsp;     * @throws IllegalArgumentException If validation fails
&nbsp;     * @throws IllegalStateException    If business rules are violated
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public AppraisalDTO createAppraisal(CreateAppraisalDTO createAppraisalDTO) {
<b class="fc">&nbsp;        LOGGER.info(&quot;Creating new appraisal for user {} by user {} in cycle {}&quot;,</b>
<b class="fc">&nbsp;                createAppraisalDTO.getAppraisedUserId(),</b>
<b class="fc">&nbsp;                createAppraisalDTO.getAppraisingUserId(),</b>
<b class="fc">&nbsp;                createAppraisalDTO.getCycleId());</b>
&nbsp;        // Validate users exist
<b class="fc">&nbsp;        UserEntity appraisedUser = userRepository.find(createAppraisalDTO.getAppraisedUserId());</b>
<b class="fc">&nbsp;        if (appraisedUser == null) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Appraised user not found&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        UserEntity appraisingUser = userRepository.find(createAppraisalDTO.getAppraisingUserId());</b>
<b class="fc">&nbsp;        if (appraisingUser == null) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Appraising user not found&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Validate cycle exists and is active
<b class="fc">&nbsp;        CycleEntity cycle = cycleRepository.find(createAppraisalDTO.getCycleId());</b>
<b class="fc">&nbsp;        if (cycle == null) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Cycle not found&quot;);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (cycle.getState() != CycleState.OPEN) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Cannot create appraisal in a closed cycle&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Check if appraisal already exists for this combination
<b class="fc">&nbsp;        AppraisalEntity existingAppraisal = appraisalRepository.findAppraisalByUsersAndCycle(</b>
<b class="fc">&nbsp;                createAppraisalDTO.getAppraisedUserId(),</b>
<b class="fc">&nbsp;                createAppraisalDTO.getAppraisingUserId(),</b>
<b class="fc">&nbsp;                createAppraisalDTO.getCycleId()</b>
&nbsp;        );
&nbsp;
<b class="fc">&nbsp;        if (existingAppraisal != null) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Appraisal already exists for this user in this cycle&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Validate that appraising user is manager of appraised user
<b class="fc">&nbsp;        if (!isManagerOfUser(appraisingUser, appraisedUser)) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;User is not authorized to appraise this user&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Create new appraisal
<b class="fc">&nbsp;        AppraisalEntity appraisalEntity = new AppraisalEntity();</b>
<b class="fc">&nbsp;        appraisalEntity.setAppraisedUser(appraisedUser);</b>
<b class="fc">&nbsp;        appraisalEntity.setAppraisingUser(appraisingUser);</b>
<b class="fc">&nbsp;        appraisalEntity.setCycle(cycle);</b>
<b class="fc">&nbsp;        appraisalEntity.setFeedback(createAppraisalDTO.getFeedback());</b>
<b class="fc">&nbsp;        appraisalEntity.setScore(createAppraisalDTO.getScore());</b>
<b class="fc">&nbsp;        appraisalEntity.setState(AppraisalState.IN_PROGRESS);</b>
<b class="fc">&nbsp;        appraisalEntity.setCreationDate(LocalDate.now());</b>
<b class="fc">&nbsp;        appraisalEntity.setEditedDate(LocalDate.now());</b>
<b class="fc">&nbsp;        appraisalRepository.persist(appraisalEntity);</b>
<b class="fc">&nbsp;        LOGGER.info(&quot;Created appraisal with ID: {}&quot;, appraisalEntity.getId());</b>
&nbsp;
<b class="fc">&nbsp;        return appraisalMapper.toDto(appraisalEntity);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Updates an existing appraisal with the provided data.
&nbsp;     *
&nbsp;     * @param updateAppraisalDTO The DTO containing updated appraisal data
&nbsp;     * @return The updated AppraisalDTO
&nbsp;     * @throws IllegalArgumentException If appraisal not found
&nbsp;     * @throws IllegalStateException    If appraisal cannot be modified
&nbsp;     */
&nbsp;    /**
&nbsp;     * Updates an existing appraisal with the provided data.
&nbsp;     *
&nbsp;     * @param updateAppraisalDTO The DTO containing updated appraisal data
&nbsp;     * @param isAdmin            Whether the update is performed by an admin
&nbsp;     * @return The updated AppraisalDTO
&nbsp;     * @throws IllegalArgumentException If appraisal not found
&nbsp;     * @throws IllegalStateException    If appraisal cannot be modified
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public AppraisalDTO updateAppraisal(UpdateAppraisalDTO updateAppraisalDTO, boolean isAdmin) {
<b class="nc">&nbsp;        LOGGER.info(&quot;Updating appraisal with ID: {}&quot;, updateAppraisalDTO.getId());</b>
&nbsp;
<b class="nc">&nbsp;        AppraisalEntity appraisal = appraisalRepository.find(updateAppraisalDTO.getId());</b>
<b class="nc">&nbsp;        if (appraisal == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Appraisal not found&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (appraisal.getState() == AppraisalState.CLOSED &amp;&amp; !isAdmin) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot modify a closed appraisal&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (appraisal.getCycle().getState() != CycleState.OPEN &amp;&amp; !isAdmin) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot modify appraisal in a closed cycle&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Update fields
<b class="nc">&nbsp;        appraisal.setFeedback(updateAppraisalDTO.getFeedback());</b>
<b class="nc">&nbsp;        appraisal.setScore(updateAppraisalDTO.getScore());</b>
<b class="nc">&nbsp;        appraisal.setEditedDate(LocalDate.now());</b>
<b class="nc">&nbsp;        appraisal.setState(updateAppraisalDTO.getState());</b>
<b class="nc">&nbsp;        appraisal.setEditedDate(LocalDate.now());</b>
<b class="nc">&nbsp;        if(updateAppraisalDTO.getState() == AppraisalState.COMPLETED) {</b>
<b class="nc">&nbsp;            appraisal.setSubmissionDate(LocalDate.now());</b>
&nbsp;        }
<b class="nc">&nbsp;        appraisalRepository.merge(appraisal);</b>
<b class="nc">&nbsp;        LOGGER.info(&quot;Updated appraisal with ID: {}&quot;, appraisal.getId());</b>
&nbsp;
<b class="nc">&nbsp;        return appraisalMapper.toDto(appraisal);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieves an appraisal by its ID and maps to a DTO.
&nbsp;     *
&nbsp;     * @param id The appraisal ID
&nbsp;     * @return The mapped AppraisalDTO, or throws if not found
&nbsp;     * @throws IllegalArgumentException If appraisal not found
&nbsp;     */
&nbsp;    /**
&nbsp;     * Retrieves an appraisal by its ID and maps to a DTO.
&nbsp;     *
&nbsp;     * @param id The appraisal ID
&nbsp;     * @return The mapped AppraisalDTO, or throws if not found
&nbsp;     * @throws IllegalArgumentException If appraisal not found
&nbsp;     */
&nbsp;    public AppraisalDTO getAppraisalById(Long id) {
<b class="nc">&nbsp;        LOGGER.debug(&quot;Retrieving appraisal with ID: {}&quot;, id);</b>
&nbsp;
<b class="nc">&nbsp;        AppraisalEntity appraisal = appraisalRepository.find(id);</b>
<b class="nc">&nbsp;        if (appraisal == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Appraisal not found&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return appraisalMapper.toDto(appraisal);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieves all appraisals for a specific user (as appraised).
&nbsp;     *
&nbsp;     * @param userId The user ID
&nbsp;     * @return List of AppraisalDTOs for the user
&nbsp;     */
&nbsp;    /**
&nbsp;     * Retrieves all appraisals for a specific user (as appraised).
&nbsp;     *
&nbsp;     * @param userId The user ID
&nbsp;     * @return List of AppraisalDTOs for the user
&nbsp;     */
&nbsp;    public List&lt;AppraisalDTO&gt; getAppraisalsByAppraisedUser(Long userId) {
<b class="fc">&nbsp;        LOGGER.debug(&quot;Retrieving appraisals for appraised user ID: {}&quot;, userId);</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;AppraisalEntity&gt; appraisals = appraisalRepository.findAppraisalsByAppraisedUser(userId);</b>
<b class="fc">&nbsp;        return appraisalMapper.toDtoList(appraisals);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieves all appraisals created by a specific manager.
&nbsp;     *
&nbsp;     * @param managerId The manager user ID
&nbsp;     * @return List of appraisal DTOs
&nbsp;     */
&nbsp;    /**
&nbsp;     * Retrieves all appraisals created by a specific manager.
&nbsp;     *
&nbsp;     * @param managerId The manager user ID
&nbsp;     * @return List of appraisal DTOs
&nbsp;     */
&nbsp;    public List&lt;AppraisalDTO&gt; getAppraisalsByManager(Long managerId) {
<b class="fc">&nbsp;        LOGGER.debug(&quot;Retrieving appraisals created by manager ID: {}&quot;, managerId);</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;AppraisalEntity&gt; appraisals = appraisalRepository.findAppraisalsByAppraisingUser(managerId);</b>
<b class="fc">&nbsp;        return appraisalMapper.toDtoList(appraisals);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieves all appraisals within a specific cycle.
&nbsp;     *
&nbsp;     * @param cycleId The cycle ID
&nbsp;     * @return List of appraisal DTOs
&nbsp;     */
&nbsp;    /**
&nbsp;     * Retrieves all appraisals within a specific cycle.
&nbsp;     *
&nbsp;     * @param cycleId The cycle ID
&nbsp;     * @return List of appraisal DTOs
&nbsp;     */
&nbsp;    public List&lt;AppraisalDTO&gt; getAppraisalsByCycle(Long cycleId) {
<b class="fc">&nbsp;        LOGGER.debug(&quot;Retrieving appraisals for cycle ID: {}&quot;, cycleId);</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;AppraisalEntity&gt; appraisals = appraisalRepository.findAppraisalsByCycle(cycleId);</b>
<b class="fc">&nbsp;        return appraisalMapper.toDtoList(appraisals);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieves appraisals with advanced filtering options.
&nbsp;     *
&nbsp;     * @param appraisedUserId  Optional filter by appraised user ID
&nbsp;     * @param appraisingUserId Optional filter by appraising user ID
&nbsp;     * @param cycleId          Optional filter by cycle ID
&nbsp;     * @param state            Optional filter by appraisal state
&nbsp;     * @param limit            Maximum number of results
&nbsp;     * @param offset           Starting position for pagination
&nbsp;     * @return List of filtered appraisal DTOs
&nbsp;     */
&nbsp;    /**
&nbsp;     * Retrieves appraisals with advanced filtering options.
&nbsp;     *
&nbsp;     * @param appraisedUserId    Optional filter by appraised user ID
&nbsp;     * @param appraisedUserName  Optional filter by appraised user name
&nbsp;     * @param appraisedUserEmail Optional filter by appraised user email
&nbsp;     * @param appraisingUserId   Optional filter by appraising user ID
&nbsp;     * @param appraisingUserName Optional filter by appraising user name
&nbsp;     * @param appraisingUserEmail Optional filter by appraising user email
&nbsp;     * @param cycleId            Optional filter by cycle ID
&nbsp;     * @param state              Optional filter by appraisal state
&nbsp;     * @param parameter          Optional filter by appraisal parameter
&nbsp;     * @param orderBy            Optional ordering
&nbsp;     * @param limit              Maximum number of results
&nbsp;     * @param offset             Starting position for pagination
&nbsp;     * @return Map containing filtered appraisal DTOs and metadata
&nbsp;     */
&nbsp;    public Map&lt;String, Object&gt; getAppraisalsWithFilters(Long appraisedUserId, String appraisedUserName, String appraisedUserEmail,
&nbsp;                                                        Long appraisingUserId, String appraisingUserName, String appraisingUserEmail,
&nbsp;                                                        Long cycleId, AppraisalState state, AppraisalParameter parameter, OrderBy orderBy,
&nbsp;                                                        Integer limit, Integer offset) {
<b class="nc">&nbsp;        LOGGER.debug(&quot;Retrieving appraisals with filters&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;AppraisalEntity&gt; appraisals = appraisalRepository.findAppraisalsWithFilters(</b>
&nbsp;                appraisedUserId, appraisedUserName, appraisedUserEmail, appraisingUserId, appraisingUserName,
&nbsp;                appraisingUserEmail, cycleId, state, parameter, orderBy, limit, offset
&nbsp;        );
<b class="nc">&nbsp;        long totalAppraisals = appraisalRepository.getTotalAppraisalsWithFilters(</b>
&nbsp;                appraisedUserId, appraisedUserName, appraisedUserEmail, appraisingUserId, appraisingUserName, appraisingUserEmail, cycleId, state);
&nbsp;
<b class="nc">&nbsp;        List&lt;AppraisalResponseDTO&gt; appraisalDTOS = appraisals.stream()</b>
<b class="nc">&nbsp;                .map(appraisalMapper::toResponseDto)</b>
<b class="nc">&nbsp;                .collect(Collectors.toList());</b>
&nbsp;
<b class="nc">&nbsp;        Map&lt;String, Object&gt; responseData = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        responseData.put(&quot;appraisals&quot;, appraisalDTOS);</b>
<b class="nc">&nbsp;        responseData.put(&quot;totalAppraisals&quot;, totalAppraisals);</b>
<b class="nc">&nbsp;        responseData.put(&quot;offset&quot;, offset);</b>
<b class="nc">&nbsp;        responseData.put(&quot;limit&quot;, limit);</b>
<b class="nc">&nbsp;        return responseData;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Generates a PDF of appraisals with the given filters.
&nbsp;     *
&nbsp;     * @param appraisedUserId    Optional filter by appraised user ID
&nbsp;     * @param appraisedUserName  Optional filter by appraised user name
&nbsp;     * @param appraisedUserEmail Optional filter by appraised user email
&nbsp;     * @param appraisingUserId   Optional filter by appraising user ID
&nbsp;     * @param appraisingUserName Optional filter by appraising user name
&nbsp;     * @param appraisingUserEmail Optional filter by appraising user email
&nbsp;     * @param cycleId            Optional filter by cycle ID
&nbsp;     * @param state              Optional filter by appraisal state
&nbsp;     * @param parameter          Optional filter by appraisal parameter
&nbsp;     * @param orderBy            Optional ordering
&nbsp;     * @param language           Language for the PDF
&nbsp;     * @return StreamingOutput for the generated PDF
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public StreamingOutput getPDFOfAppraisals(Long appraisedUserId,
&nbsp;                                              String appraisedUserName,
&nbsp;                                              String appraisedUserEmail,
&nbsp;                                              Long appraisingUserId,
&nbsp;                                              String appraisingUserName,
&nbsp;                                              String appraisingUserEmail,
&nbsp;                                              Long cycleId,
&nbsp;                                              AppraisalState state,
&nbsp;                                              AppraisalParameter parameter,
&nbsp;                                              OrderBy orderBy,
&nbsp;                                              Language language) {
<b class="nc">&nbsp;        LOGGER.debug(&quot;Retrieving appraisals with filters&quot;);</b>
&nbsp;
&nbsp;        // 1. Fetch all data needed within the transaction
<b class="nc">&nbsp;        List&lt;AppraisalEntity&gt; appraisals = appraisalRepository.findAppraisalsWithFilters(</b>
&nbsp;                appraisedUserId, appraisedUserName, appraisedUserEmail,
&nbsp;                appraisingUserId, appraisingUserName, appraisingUserEmail,
&nbsp;                cycleId, state, parameter, orderBy, null, null);
&nbsp;
<b class="nc">&nbsp;        LOGGER.info(&quot;Found {} appraisals for PDF export&quot;, appraisals.size());</b>
&nbsp;
&nbsp;        // 2. Convert to DTOs and fully initialize all needed data
<b class="nc">&nbsp;        List&lt;AppraisalResponseDTO&gt; appraisalDTOs = appraisals.stream()</b>
<b class="nc">&nbsp;                .map(appraisal -&gt; {</b>
<b class="nc">&nbsp;                    AppraisalResponseDTO dto = appraisalMapper.toResponseDto(appraisal);</b>
&nbsp;                    // Force loading of any lazy-loaded relationships if needed
<b class="nc">&nbsp;                    if (dto.getAppraisedUser() != null) {</b>
<b class="nc">&nbsp;                        dto.getAppraisedUser().getName(); // Trigger proxy initialization</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return dto;</b>
&nbsp;                })
<b class="nc">&nbsp;                .collect(Collectors.toList());</b>
&nbsp;
&nbsp;        // 3. Return the streaming output
<b class="nc">&nbsp;        return output -&gt; {</b>
&nbsp;            try {
<b class="nc">&nbsp;                PdfGenerator.generateAppraisalsPdf(appraisalDTOs, output, language);</b>
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                LOGGER.error(&quot;PDF generation failed&quot;, e);</b>
<b class="nc">&nbsp;                throw new RuntimeException(&quot;Failed to generate PDF&quot;, e);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Completes an appraisal, changing its state to COMPLETED.
&nbsp;     *
&nbsp;     * @param appraisalId The appraisal ID
&nbsp;     * @return The updated appraisal DTO
&nbsp;     * @throws IllegalArgumentException If appraisal not found
&nbsp;     * @throws IllegalStateException    If appraisal cannot be completed
&nbsp;     */
&nbsp;    /**
&nbsp;     * Completes an appraisal, changing its state to COMPLETED.
&nbsp;     *
&nbsp;     * @param appraisalId The appraisal ID
&nbsp;     * @return The updated appraisal DTO
&nbsp;     * @throws IllegalArgumentException If appraisal not found
&nbsp;     * @throws IllegalStateException    If appraisal cannot be completed
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public AppraisalDTO completeAppraisal(Long appraisalId) {
<b class="nc">&nbsp;        LOGGER.info(&quot;Completing appraisal with ID: {}&quot;, appraisalId);</b>
&nbsp;
<b class="nc">&nbsp;        AppraisalEntity appraisal = appraisalRepository.find(appraisalId);</b>
<b class="nc">&nbsp;        if (appraisal == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Appraisal not found&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (appraisal.getState() == AppraisalState.CLOSED) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot complete a closed appraisal&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        appraisal.setState(AppraisalState.COMPLETED);</b>
<b class="nc">&nbsp;        appraisal.setEditedDate(LocalDate.now());</b>
<b class="nc">&nbsp;        appraisalRepository.merge(appraisal);</b>
<b class="nc">&nbsp;        LOGGER.info(&quot;Completed appraisal with ID: {}&quot;, appraisal.getId());</b>
&nbsp;
<b class="nc">&nbsp;        return appraisalMapper.toDto(appraisal);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Closes an appraisal, changing its state to CLOSED.
&nbsp;     *
&nbsp;     * @param appraisalId The appraisal ID
&nbsp;     * @return The updated appraisal DTO
&nbsp;     * @throws IllegalArgumentException If appraisal not found
&nbsp;     */
&nbsp;    /**
&nbsp;     * Closes an appraisal, changing its state to CLOSED.
&nbsp;     *
&nbsp;     * @param appraisalId The appraisal ID
&nbsp;     * @return The updated appraisal DTO
&nbsp;     * @throws IllegalArgumentException If appraisal not found
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public AppraisalDTO closeAppraisal(Long appraisalId) {
<b class="nc">&nbsp;        LOGGER.info(&quot;Closing appraisal with ID: {}&quot;, appraisalId);</b>
&nbsp;
<b class="nc">&nbsp;        AppraisalEntity appraisal = appraisalRepository.find(appraisalId);</b>
<b class="nc">&nbsp;        if (appraisal == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Appraisal not found&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        appraisal.setState(AppraisalState.CLOSED);</b>
<b class="nc">&nbsp;        appraisal.setEditedDate(LocalDate.now());</b>
<b class="nc">&nbsp;        appraisalRepository.merge(appraisal);</b>
<b class="nc">&nbsp;        LOGGER.info(&quot;Closed appraisal with ID: {}&quot;, appraisal.getId());</b>
&nbsp;
<b class="nc">&nbsp;        return appraisalMapper.toDto(appraisal);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes an appraisal by its ID.
&nbsp;     *
&nbsp;     * @param appraisalId The appraisal ID
&nbsp;     * @throws IllegalArgumentException If appraisal not found
&nbsp;     * @throws IllegalStateException    If appraisal cannot be deleted
&nbsp;     */
&nbsp;    /**
&nbsp;     * Deletes an appraisal by its ID.
&nbsp;     *
&nbsp;     * @param appraisalId The appraisal ID
&nbsp;     * @throws IllegalArgumentException If appraisal not found
&nbsp;     * @throws IllegalStateException    If appraisal cannot be deleted
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public void deleteAppraisal(Long appraisalId) {
<b class="nc">&nbsp;        LOGGER.info(&quot;Deleting appraisal with ID: {}&quot;, appraisalId);</b>
&nbsp;
<b class="nc">&nbsp;        AppraisalEntity appraisal = appraisalRepository.find(appraisalId);</b>
<b class="nc">&nbsp;        if (appraisal == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Appraisal not found&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (appraisal.getState() == AppraisalState.CLOSED) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot delete a closed appraisal&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        appraisalRepository.remove(appraisal);</b>
<b class="nc">&nbsp;        LOGGER.info(&quot;Deleted appraisal with ID: {}&quot;, appraisalId);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets appraisal statistics for a user.
&nbsp;     *
&nbsp;     * @param userId The user ID
&nbsp;     * @return Map containing appraisal statistics
&nbsp;     */
&nbsp;    /**
&nbsp;     * Gets appraisal statistics for a user.
&nbsp;     *
&nbsp;     * @param userId The user ID
&nbsp;     * @return AppraisalStatsDTO containing appraisal statistics
&nbsp;     */
&nbsp;    public AppraisalStatsDTO getAppraisalStats(Long userId) {
<b class="fc">&nbsp;        LOGGER.debug(&quot;Getting appraisal statistics for user ID: {}&quot;, userId);</b>
<b class="fc">&nbsp;        Long receivedCount = appraisalRepository.countAppraisalsByUser(userId, true);</b>
<b class="fc">&nbsp;        Long givenCount = appraisalRepository.countAppraisalsByUser(userId, false);</b>
<b class="fc">&nbsp;        AppraisalStatsDTO stats = new AppraisalStatsDTO();</b>
<b class="fc">&nbsp;        stats.setUserId(userId);</b>
<b class="fc">&nbsp;        stats.setReceivedAppraisalsCount(receivedCount);</b>
<b class="fc">&nbsp;        stats.setGivenAppraisalsCount(givenCount);</b>
&nbsp;
<b class="fc">&nbsp;        return stats;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if a user is a manager of another user.
&nbsp;     * This is a simplified implementation - adjust based on your business logic.
&nbsp;     *
&nbsp;     * @param manager The potential manager
&nbsp;     * @param user    The user to check
&nbsp;     * @return True if manager is authorized to appraise the user
&nbsp;     */
&nbsp;    public boolean isManagerOfUser(UserEntity manager, UserEntity user) {
<b class="fc">&nbsp;        return !manager.getId().equals(user.getId());</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Closes specific appraisals by their IDs.
&nbsp;     * Only COMPLETED appraisals in OPEN cycles can be closed.
&nbsp;     *
&nbsp;     * @param appraisalIds List of appraisal IDs to close
&nbsp;     * @return Number of successfully closed appraisals
&nbsp;     * @throws IllegalArgumentException If no valid appraisals found
&nbsp;     */
&nbsp;    /**
&nbsp;     * Closes specific appraisals by their IDs.
&nbsp;     * Only COMPLETED appraisals in OPEN cycles can be closed.
&nbsp;     *
&nbsp;     * @param appraisalIds List of appraisal IDs to close
&nbsp;     * @return Number of successfully closed appraisals
&nbsp;     * @throws IllegalArgumentException If no valid appraisals found
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public int closeAppraisalsByIds(List&lt;Long&gt; appraisalIds) {
<b class="nc">&nbsp;        LOGGER.info(&quot;Attempting to close appraisals by IDs: {}&quot;, appraisalIds);</b>
&nbsp;
<b class="nc">&nbsp;        if (appraisalIds == null || appraisalIds.isEmpty()) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;No appraisal IDs provided&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        List&lt;AppraisalEntity&gt; validAppraisals = appraisalRepository.findValidAppraisalsForClosing(appraisalIds);</b>
&nbsp;
<b class="nc">&nbsp;        if (validAppraisals.isEmpty()) {</b>
<b class="nc">&nbsp;            LOGGER.warn(&quot;No valid COMPLETED appraisals found in OPEN cycles for IDs: {}&quot;, appraisalIds);</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;No valid appraisals found for closing. Only COMPLETED appraisals in OPEN cycles can be closed.&quot;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int closedCount = 0;</b>
<b class="nc">&nbsp;        for (AppraisalEntity appraisal : validAppraisals) {</b>
<b class="nc">&nbsp;            appraisal.setState(AppraisalState.CLOSED);</b>
<b class="nc">&nbsp;            appraisalRepository.merge(appraisal);</b>
<b class="nc">&nbsp;            closedCount++;</b>
<b class="nc">&nbsp;            LOGGER.debug(&quot;Closed appraisal ID: {} for user: {}&quot;, appraisal.getId(), appraisal.getAppraisedUser().getId());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        LOGGER.info(&quot;Successfully closed {} appraisals by IDs&quot;, closedCount);</b>
<b class="nc">&nbsp;        return closedCount;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Closes all COMPLETED appraisals in a specific cycle.
&nbsp;     * Only works if the cycle is OPEN.
&nbsp;     *
&nbsp;     * @param cycleId The cycle ID
&nbsp;     * @return Number of successfully closed appraisals
&nbsp;     * @throws IllegalArgumentException If cycle not found or not OPEN
&nbsp;     */
&nbsp;    /**
&nbsp;     * Closes all COMPLETED appraisals in a specific cycle.
&nbsp;     * Only works if the cycle is OPEN.
&nbsp;     *
&nbsp;     * @param cycleId The cycle ID
&nbsp;     * @return Number of successfully closed appraisals
&nbsp;     * @throws IllegalArgumentException If cycle not found or not OPEN
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public int closeCompletedAppraisalsByCycleId(Long cycleId) {
<b class="nc">&nbsp;        LOGGER.info(&quot;Attempting to close all COMPLETED appraisals in cycle ID: {}&quot;, cycleId);</b>
&nbsp;
&nbsp;        // Verify cycle exists and is OPEN
<b class="nc">&nbsp;        CycleEntity cycle = cycleRepository.find(cycleId);</b>
<b class="nc">&nbsp;        if (cycle == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Cycle not found with ID: &quot; + cycleId);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (cycle.getState() != CycleState.OPEN) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot close appraisals in a CLOSED cycle. Cycle ID: &quot; + cycleId);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        List&lt;AppraisalEntity&gt; completedAppraisals = appraisalRepository.findCompletedAppraisalsByCycleId(cycleId);</b>
&nbsp;
<b class="nc">&nbsp;        if (completedAppraisals.isEmpty()) {</b>
<b class="nc">&nbsp;            LOGGER.info(&quot;No COMPLETED appraisals found in cycle ID: {}&quot;, cycleId);</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int closedCount = 0;</b>
<b class="nc">&nbsp;        for (AppraisalEntity appraisal : completedAppraisals) {</b>
<b class="nc">&nbsp;            appraisal.setState(AppraisalState.CLOSED);</b>
<b class="nc">&nbsp;            appraisalRepository.merge(appraisal);</b>
<b class="nc">&nbsp;            closedCount++;</b>
<b class="nc">&nbsp;            LOGGER.debug(&quot;Closed appraisal ID: {} in cycle: {}&quot;, appraisal.getId(), cycleId);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        LOGGER.info(&quot;Successfully closed {} COMPLETED appraisals in cycle ID: {}&quot;, closedCount, cycleId);</b>
<b class="nc">&nbsp;        return closedCount;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Closes all COMPLETED appraisals for a specific user.
&nbsp;     * Only works for appraisals in OPEN cycles.
&nbsp;     *
&nbsp;     * @param userId The user ID (appraised user)
&nbsp;     * @return Number of successfully closed appraisals
&nbsp;     * @throws IllegalArgumentException If user not found
&nbsp;     */
&nbsp;    /**
&nbsp;     * Closes all COMPLETED appraisals for a specific user.
&nbsp;     * Only works for appraisals in OPEN cycles.
&nbsp;     *
&nbsp;     * @param userId The user ID (appraised user)
&nbsp;     * @return Number of successfully closed appraisals
&nbsp;     * @throws IllegalArgumentException If user not found
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public int closeCompletedAppraisalsByUserId(Long userId) {
<b class="nc">&nbsp;        LOGGER.info(&quot;Attempting to close all COMPLETED appraisals for user ID: {}&quot;, userId);</b>
&nbsp;
&nbsp;        // Verify user exists
<b class="nc">&nbsp;        UserEntity user = userRepository.find(userId);</b>
<b class="nc">&nbsp;        if (user == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;User not found with ID: &quot; + userId);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        List&lt;AppraisalEntity&gt; completedAppraisals = appraisalRepository.findCompletedAppraisalsByUserId(userId);</b>
&nbsp;
<b class="nc">&nbsp;        if (completedAppraisals.isEmpty()) {</b>
<b class="nc">&nbsp;            LOGGER.info(&quot;No COMPLETED appraisals found for user ID: {}&quot;, userId);</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int closedCount = 0;</b>
<b class="nc">&nbsp;        for (AppraisalEntity appraisal : completedAppraisals) {</b>
<b class="nc">&nbsp;            appraisal.setState(AppraisalState.CLOSED);</b>
<b class="nc">&nbsp;            appraisalRepository.merge(appraisal);</b>
<b class="nc">&nbsp;            closedCount++;</b>
<b class="nc">&nbsp;            LOGGER.debug(&quot;Closed appraisal ID: {} for user: {}&quot;, appraisal.getId(), userId);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        LOGGER.info(&quot;Successfully closed {} COMPLETED appraisals for user ID: {}&quot;, closedCount, userId);</b>
<b class="nc">&nbsp;        return closedCount;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Closes all COMPLETED appraisals in all OPEN cycles.
&nbsp;     * Administrative operation.
&nbsp;     *
&nbsp;     * @return Number of successfully closed appraisals
&nbsp;     */
&nbsp;    /**
&nbsp;     * Closes all COMPLETED appraisals in all OPEN cycles.
&nbsp;     * Administrative operation.
&nbsp;     *
&nbsp;     * @return Number of successfully closed appraisals
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public int closeAllCompletedAppraisals() {
<b class="nc">&nbsp;        LOGGER.info(&quot;Attempting to close ALL COMPLETED appraisals in OPEN cycles&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        List&lt;AppraisalEntity&gt; completedAppraisals = appraisalRepository.findAllCompletedAppraisalsInOpenCycles();</b>
&nbsp;
<b class="nc">&nbsp;        if (completedAppraisals.isEmpty()) {</b>
<b class="nc">&nbsp;            LOGGER.info(&quot;No COMPLETED appraisals found in OPEN cycles&quot;);</b>
<b class="nc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int closedCount = 0;</b>
<b class="nc">&nbsp;        for (AppraisalEntity appraisal : completedAppraisals) {</b>
<b class="nc">&nbsp;            appraisal.setState(AppraisalState.CLOSED);</b>
<b class="nc">&nbsp;            appraisalRepository.merge(appraisal);</b>
<b class="nc">&nbsp;            closedCount++;</b>
<b class="nc">&nbsp;            LOGGER.debug(&quot;Closed appraisal ID: {} in cycle: {}&quot;, appraisal.getId(), appraisal.getCycle().getId());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        LOGGER.info(&quot;Successfully closed {} COMPLETED appraisals across all OPEN cycles&quot;, closedCount);</b>
<b class="nc">&nbsp;        return closedCount;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the given manager is the appraising user for the specified appraisal.
&nbsp;     *
&nbsp;     * @param appraisalId The appraisal ID
&nbsp;     * @param managerId   The manager&#39;s user ID
&nbsp;     * @return True if the manager is the appraising user, false otherwise
&nbsp;     */
&nbsp;    public boolean checkIfManagerOfUser(Long appraisalId, Long managerId) {
&nbsp;        try {
<b class="fc">&nbsp;            AppraisalEntity appraisal = appraisalRepository.find(appraisalId);</b>
<b class="fc">&nbsp;            if (appraisal == null) {</b>
<b class="fc">&nbsp;                LOGGER.warn(&quot;Appraisal not found with ID: {}&quot;, appraisalId);</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            return appraisal.getAppraisingUser().getId().equals(managerId);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            LOGGER.error(&quot;Error checking manager of user for appraisal ID: {}&quot;, appraisalId, e);</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Counts all appraisals in the system.
&nbsp;     *
&nbsp;     * @return Total number of appraisals
&nbsp;     */
&nbsp;    public long countAllAppraisals() {
<b class="fc">&nbsp;        return appraisalRepository.getTotalAppraisalsWithFilters(null, null, null, null, null, null, null, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Counts all appraisals by a specific state.
&nbsp;     *
&nbsp;     * @param state The appraisal state to filter by
&nbsp;     * @return Total number of appraisals in the given state
&nbsp;     */
&nbsp;    public long countAppraisalsByState(AppraisalState state) {
<b class="fc">&nbsp;        return appraisalRepository.getTotalAppraisalsWithFilters(null, null, null, null, null, null, null, state);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-07-15 20:29</div>
</div>
</body>
</html>
