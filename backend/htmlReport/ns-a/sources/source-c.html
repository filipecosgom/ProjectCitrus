


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > UserService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">pt.uc.dei.services</a>
</div>

<h1>Coverage Summary for Class: UserService (pt.uc.dei.services)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">UserService</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (15/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28.4%
  </span>
  <span class="absValue">
    (33/116)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40.5%
  </span>
  <span class="absValue">
    (89/220)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package pt.uc.dei.services;
&nbsp;
&nbsp;import pt.uc.dei.dtos.FinishedCourseDTO;
&nbsp;import pt.uc.dei.mapper.FinishedCourseMapper;
&nbsp;import com.warrenstrange.googleauth.GoogleAuthenticatorKey;
&nbsp;import jakarta.ejb.EJB;
&nbsp;import jakarta.ejb.Stateless;
&nbsp;import jakarta.inject.Inject;
&nbsp;import jakarta.transaction.Transactional;
&nbsp;import org.apache.logging.log4j.LogManager;
&nbsp;import org.apache.logging.log4j.Logger;
&nbsp;import pt.uc.dei.dtos.*;
&nbsp;import pt.uc.dei.repositories.AppraisalRepository;
&nbsp;import pt.uc.dei.repositories.CourseRepository;
&nbsp;import pt.uc.dei.repositories.FinishedCourseRepository;
&nbsp;import pt.uc.dei.utils.CSVGenerator;
&nbsp;import pt.uc.dei.utils.JWTUtil;
&nbsp;import pt.uc.dei.entities.ActivationTokenEntity;
&nbsp;import pt.uc.dei.entities.CourseEntity;
&nbsp;import pt.uc.dei.entities.FinishedCourseEntity;
&nbsp;import pt.uc.dei.entities.TemporaryUserEntity;
&nbsp;import pt.uc.dei.entities.UserEntity;
&nbsp;import pt.uc.dei.enums.*;
&nbsp;import pt.uc.dei.mapper.UserMapper;
&nbsp;import pt.uc.dei.repositories.ActivationTokenRepository;
&nbsp;import pt.uc.dei.repositories.TemporaryUserRepository;
&nbsp;import pt.uc.dei.repositories.UserRepository;
&nbsp;import pt.uc.dei.utils.PasswordUtils;
&nbsp;import pt.uc.dei.utils.TwoFactorUtil;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.time.LocalDate;
&nbsp;import java.time.LocalDateTime;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.concurrent.Future;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;/**
&nbsp; * Service class for managing user-related operations in the system.
&nbsp; * &lt;p&gt;
&nbsp; * Provides functionality for user verification, registration, activation, profile management,
&nbsp; * finished courses, admin permissions, and temporary user management. Integrates with repositories,
&nbsp; * mappers, notification and email services, and utilities for persistence and business logic.
&nbsp; * &lt;p&gt;
&nbsp; * This class is a stateless EJB, making it eligible for dependency injection and transaction management.
&nbsp; */
&nbsp;@Stateless
<b class="fc">&nbsp;public class UserService implements Serializable {</b>
&nbsp;    /**
&nbsp;     * Logger instance for logging user service operations.
&nbsp;     */
<b class="fc">&nbsp;    private static final Logger LOGGER = LogManager.getLogger(UserService.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Serial version UID for ensuring class consistency during serialization.
&nbsp;     */
&nbsp;    private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;    /**
&nbsp;     * Injected repository for managing permanent users.
&nbsp;     */
&nbsp;    @EJB
&nbsp;    UserRepository userRepository;
&nbsp;
&nbsp;    @EJB
&nbsp;    AppraisalRepository appraisalRepository;
&nbsp;
&nbsp;    @EJB
&nbsp;    NotificationService notificationService;
&nbsp;
&nbsp;    /**
&nbsp;     * Injected repository for managing temporary users.
&nbsp;     */
&nbsp;    @EJB
&nbsp;    TemporaryUserRepository temporaryUserRepository;
&nbsp;
&nbsp;    /**
&nbsp;     * Injected service for token-related operations.
&nbsp;     */
&nbsp;    @EJB
&nbsp;    TokenService tokenService;
&nbsp;
&nbsp;
&nbsp;    @EJB
&nbsp;    CourseRepository courseRepository;
&nbsp;
&nbsp;    @EJB
&nbsp;    FinishedCourseRepository finishedCourseRepository;
&nbsp;
&nbsp;    @EJB
&nbsp;    EmailService emailService;
&nbsp;
&nbsp;    @Inject
&nbsp;    JWTUtil jwtUtil;
&nbsp;
&nbsp;    @Inject
&nbsp;    UserMapper userMapper;
&nbsp;
&nbsp;    @Inject
&nbsp;    FinishedCourseMapper finishedCourseMapper;
&nbsp;
&nbsp;    @Inject
&nbsp;    TwoFactorUtil twoFactorUtil;
&nbsp;
&nbsp;    /**
&nbsp;     * Injected repository for activation token persistence.
&nbsp;     */
&nbsp;    @EJB
&nbsp;    ActivationTokenRepository activationTokenRepository;
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if a user with the given email exists in the system.
&nbsp;     * &lt;p&gt;
&nbsp;     * Searches both permanent and temporary repositories to verify whether the email is registered.
&nbsp;     *
&nbsp;     * @param email The email address to check for existence.
&nbsp;     * @return {@code true} if a user (permanent or temporary) exists with the email, {@code false} otherwise.
&nbsp;     */
&nbsp;    public boolean findIfUserExists(String email) {
<b class="fc">&nbsp;        UserEntity user = userRepository.findUserByEmail(email);</b>
<b class="fc">&nbsp;        TemporaryUserEntity temporaryUser = temporaryUserRepository.findTemporaryUserByEmail(email);</b>
<b class="fc">&nbsp;        return (temporaryUser != null || user != null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Registers a new temporary user in the system.
&nbsp;     * &lt;p&gt;
&nbsp;     * Generates an activation token and persists the temporary user in the repository.
&nbsp;     * Also generates a secret key for two-factor authentication.
&nbsp;     *
&nbsp;     * @param newUser The temporary user data transfer object.
&nbsp;     * @return Map containing the generated activation token and secret key for the new user.
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public Map&lt;String, String&gt; registerUser(TemporaryUserDTO newUser) {
<b class="nc">&nbsp;        TemporaryUserEntity user = new TemporaryUserEntity();</b>
<b class="nc">&nbsp;        user.setEmail(newUser.getEmail());</b>
<b class="nc">&nbsp;        user.setPassword(PasswordUtils.encrypt(newUser.getPassword()));</b>
<b class="nc">&nbsp;        ActivationTokenEntity token = new ActivationTokenEntity();</b>
<b class="nc">&nbsp;        token.setTokenValue(tokenService.generateNewToken());</b>
<b class="nc">&nbsp;        token.setCreationDate(LocalDateTime.now());</b>
<b class="nc">&nbsp;        token.setTemporaryUser(user);</b>
<b class="nc">&nbsp;        user.setActivationToken(token);</b>
<b class="nc">&nbsp;        GoogleAuthenticatorKey googleAuthenticatorKey = TwoFactorUtil.generateSecretKey();</b>
<b class="nc">&nbsp;        String secretKey = TwoFactorUtil.getSecretKeyString(googleAuthenticatorKey);</b>
<b class="nc">&nbsp;        user.setSecretKey(secretKey);</b>
<b class="nc">&nbsp;        temporaryUserRepository.persist(user);</b>
<b class="nc">&nbsp;        Map&lt;String, String&gt; codes = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        codes.put(&quot;token&quot;, token.getTokenValue());</b>
<b class="nc">&nbsp;        codes.put(&quot;secretKey&quot;, secretKey);</b>
&nbsp;
<b class="nc">&nbsp;        LOGGER.info(&quot;New user created with email {} and activation token {}&quot;, newUser.getEmail(),</b>
<b class="nc">&nbsp;                token.getTokenValue());</b>
<b class="nc">&nbsp;        return codes;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Updates an existing user with the provided data.
&nbsp;     * Only non-null fields in the DTO are updated.
&nbsp;     * Also updates manager status and notifies relevant parties if needed.
&nbsp;     *
&nbsp;     * @param id            The ID of the user to update
&nbsp;     * @param updateUserDTO The DTO containing updated user data
&nbsp;     * @return true if the update was successful, false otherwise
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public Boolean updateUser(Long id, UpdateUserDTO updateUserDTO) {
&nbsp;        // Fetch the user from the repository
<b class="fc">&nbsp;        UserEntity user = userRepository.findUserById(id);</b>
<b class="pc">&nbsp;        if (user == null) {</b>
<b class="fc">&nbsp;            LOGGER.error(&quot;Update user - user not found&quot;);</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getManagerId() != null) {</b>
<b class="nc">&nbsp;            UserEntity previousManager = user.getManagerUser();</b>
<b class="nc">&nbsp;            UserEntity newManager = userRepository.findUserById(updateUserDTO.getManagerId());</b>
<b class="nc">&nbsp;            if (newManager != null) {</b>
&nbsp;                // 1. Move all appraisals to new manager
<b class="nc">&nbsp;                appraisalRepository.setAppraisalsToNewManager(user.getId(), newManager.getId());</b>
&nbsp;                // 2. Set new manager as user&#39;s manager
<b class="nc">&nbsp;                user.setManagerUser(newManager);</b>
<b class="nc">&nbsp;                newManager.setUserIsManager(true);</b>
<b class="nc">&nbsp;                userRepository.merge(user);</b>
<b class="nc">&nbsp;                userRepository.merge(newManager);</b>
&nbsp;            }
&nbsp;            // 3. If there was a previous manager, check if they still manage anyone
<b class="nc">&nbsp;            if (previousManager != null &amp;&amp; !checkIfUserStillIsManager(previousManager.getId())) {</b>
<b class="nc">&nbsp;                updateManagerStatus(previousManager);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (updateUserDTO.getUserIsManager() != null) {</b>
<b class="nc">&nbsp;            user.setUserIsManager(updateUserDTO.getUserIsManager());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getHasAvatar() != null) {</b>
<b class="nc">&nbsp;            user.setHasAvatar(updateUserDTO.getHasAvatar());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getName() != null) {</b>
<b class="nc">&nbsp;            user.setName(updateUserDTO.getName());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getSurname() != null) {</b>
<b class="nc">&nbsp;            user.setSurname(updateUserDTO.getSurname());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getUserIsAdmin() != null) {</b>
<b class="nc">&nbsp;            user.setUserIsAdmin(updateUserDTO.getUserIsAdmin());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getUserIsDeleted() != null) {</b>
<b class="nc">&nbsp;            user.setUserIsDeleted(updateUserDTO.getUserIsDeleted());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getUserIsManager() != null) {</b>
<b class="nc">&nbsp;            user.setUserIsManager(updateUserDTO.getUserIsManager());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getOffice() != null) {</b>
<b class="nc">&nbsp;            user.setOffice(updateUserDTO.getOffice());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getPhone() != null) {</b>
<b class="nc">&nbsp;            user.setPhone(updateUserDTO.getPhone());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getBirthdate() != null) {</b>
<b class="nc">&nbsp;            user.setBirthdate(updateUserDTO.getBirthdate());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getStreet() != null) {</b>
<b class="nc">&nbsp;            user.setStreet(updateUserDTO.getStreet());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getPostalCode() != null) {</b>
<b class="nc">&nbsp;            user.setPostalCode(updateUserDTO.getPostalCode());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getMunicipality() != null) {</b>
<b class="nc">&nbsp;            user.setMunicipality(updateUserDTO.getMunicipality());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getBiography() != null) {</b>
<b class="nc">&nbsp;            user.setBiography(updateUserDTO.getBiography());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getAccountState() != null) {</b>
<b class="nc">&nbsp;            user.setAccountState(updateUserDTO.getAccountState());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (updateUserDTO.getRole() != null) {</b>
<b class="nc">&nbsp;            user.setRole(updateUserDTO.getRole());</b>
&nbsp;        }
&nbsp;
&nbsp;        // Chama aqui para atualizar o accountState se necessário
<b class="nc">&nbsp;        checkAndUpdateAccountState(id);</b>
<b class="nc">&nbsp;        notificationService.newUserUpdateNotification(user);</b>
&nbsp;
<b class="nc">&nbsp;        String userName = null;</b>
<b class="nc">&nbsp;        if(user.getName() != null &amp;&amp; user.getSurname() != null) {</b>
<b class="nc">&nbsp;             userName = user.getName() + &quot; &quot; + user.getSurname();</b>
&nbsp;        }
<b class="nc">&nbsp;        String date = LocalDate.now().toString();</b>
<b class="nc">&nbsp;        if( user.getManager() != null &amp;&amp; user.getManager().getEmail() != null) {</b>
<b class="nc">&nbsp;            if(userName == null) {</b>
<b class="nc">&nbsp;                userName = user.getEmail();</b>
&nbsp;            }
<b class="nc">&nbsp;            emailService.sendUserUpdateNotificationEmail(user.getManager().getEmail(),</b>
<b class="nc">&nbsp;                    user.getManager().getName(), userName, user.getId(), date);</b>
&nbsp;        }
<b class="nc">&nbsp;        userRepository.persist(user);</b>
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieves a user by their unique ID and maps to a UserDTO.
&nbsp;     *
&nbsp;     * @param id The user ID
&nbsp;     * @return The mapped UserDTO, or null if not found
&nbsp;     */
&nbsp;    public UserDTO getUser(Long id) {
<b class="fc">&nbsp;        UserEntity user = userRepository.findUserById(id);</b>
<b class="fc">&nbsp;        UserDTO userDTO = userMapper.toDto(user);</b>
<b class="fc">&nbsp;        return userDTO;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieves a user profile by ID, with either full or summary response.
&nbsp;     *
&nbsp;     * @param id           The user ID
&nbsp;     * @param fullResponse If true, returns full DTO; if false, returns summary DTO
&nbsp;     * @return The mapped UserDTO (full or summary), or null if not found
&nbsp;     */
&nbsp;    public UserDTO getUserProfile(Long id, boolean fullResponse) {
<b class="fc">&nbsp;        UserEntity user = userRepository.findUserById(id);</b>
<b class="fc">&nbsp;        UserDTO userDTO = new UserDTO();</b>
<b class="fc">&nbsp;        if(fullResponse) {</b>
<b class="fc">&nbsp;            userDTO = userMapper.toFullDto(user);</b>
&nbsp;        }
&nbsp;        else {
<b class="fc">&nbsp;            userDTO = userMapper.toUserResponseDto(user);</b>
&nbsp;        }
<b class="fc">&nbsp;        return userDTO;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Retrieves a paginated and filtered list of users as DTOs, with total count and pagination info.
&nbsp;     *
&nbsp;     * @param id             User ID to filter (optional)
&nbsp;     * @param email          Email to filter (optional)
&nbsp;     * @param name           Name or surname to filter (optional)
&nbsp;     * @param phone          Phone number to filter (optional)
&nbsp;     * @param accountState   Account state to filter (optional)
&nbsp;     * @param roleStr        Role to filter (optional)
&nbsp;     * @param office         Office to filter (optional)
&nbsp;     * @param userIsManager  Manager filter (optional)
&nbsp;     * @param userIsAdmin    Admin filter (optional)
&nbsp;     * @param userHasManager Managed filter (optional)
&nbsp;     * @param parameter      Sorting parameter (optional)
&nbsp;     * @param orderBy        Sorting order (ASCENDING or DESCENDING)
&nbsp;     * @param offset         Pagination offset (start position)
&nbsp;     * @param limit          Pagination limit (max results)
&nbsp;     * @return Map containing the list of users, total count, offset, and limit
&nbsp;     */
&nbsp;    public Map&lt;String, Object&gt; getUsers(Long id, String email, String name, String phone,
&nbsp;            AccountState accountState, String roleStr, Office office,
&nbsp;            Boolean userIsManager, Boolean userIsAdmin, Boolean userHasManager,
&nbsp;            Parameter parameter, OrderBy orderBy, int offset, int limit) {
&nbsp;
<b class="nc">&nbsp;        List&lt;UserEntity&gt; users = userRepository.getUsers(id, email, name, phone,</b>
&nbsp;                accountState, roleStr, office,
&nbsp;                userIsManager, userIsAdmin, userHasManager,
<b class="nc">&nbsp;                parameter, orderBy, offset, limit);</b>
<b class="nc">&nbsp;        long totalUsers = userRepository.getTotalUserCount(id, email, name, phone,</b>
&nbsp;                accountState, roleStr, office, userIsManager, userIsAdmin, userHasManager);
<b class="nc">&nbsp;        List&lt;UserResponseDTO&gt; userDtos = users.stream()</b>
<b class="nc">&nbsp;                .map(userMapper::toUserResponseDto)</b>
<b class="nc">&nbsp;                .collect(Collectors.toList());</b>
&nbsp;
<b class="nc">&nbsp;        Map&lt;String, Object&gt; responseData = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        responseData.put(&quot;users&quot;, userDtos);</b>
<b class="nc">&nbsp;        responseData.put(&quot;totalUsers&quot;, totalUsers);</b>
<b class="nc">&nbsp;        responseData.put(&quot;offset&quot;, offset);</b>
<b class="nc">&nbsp;        responseData.put(&quot;limit&quot;, limit);</b>
<b class="nc">&nbsp;        return responseData;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Generates a CSV file of all users matching the given filters and sorting (no pagination).
&nbsp;     *
&nbsp;     * @param id             User ID to filter (optional)
&nbsp;     * @param email          Email to filter (optional)
&nbsp;     * @param name           Name or surname to filter (optional)
&nbsp;     * @param phone          Phone number to filter (optional)
&nbsp;     * @param accountState   Account state to filter (optional)
&nbsp;     * @param roleStr        Role to filter (optional)
&nbsp;     * @param office         Office to filter (optional)
&nbsp;     * @param userIsManager  Manager filter (optional)
&nbsp;     * @param userIsAdmin    Admin filter (optional)
&nbsp;     * @param userHasManager Managed filter (optional)
&nbsp;     * @param lang           Language for header translation
&nbsp;     * @param parameter      Sorting parameter (optional)
&nbsp;     * @param orderBy        Sorting order (ASCENDING or DESCENDING)
&nbsp;     * @param isAdmin        Whether the export is performed by an admin (affects columns)
&nbsp;     * @return CSV file as byte array
&nbsp;     * @throws RuntimeException if CSV generation fails
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public byte[] generateUsersCSV(Long id, String email, String name, String phone,
&nbsp;            AccountState accountState, String roleStr, Office office,
&nbsp;            Boolean userIsManager, Boolean userIsAdmin, Boolean userHasManager, Language lang,
&nbsp;            Parameter parameter, OrderBy orderBy, boolean isAdmin) {
&nbsp;        try {
<b class="fc">&nbsp;        LOGGER.info(&quot;Generating CSV for users with filters: id={}, email={}, name={}, phone={}, accountState={}, roleStr={}, office={}, userIsManager={}, userIsAdmin={}, userHasManager={}, parameter={}, orderBy={}&quot;,</b>
&nbsp;                id, email, name, phone, accountState, roleStr, office, userIsManager, userIsAdmin, userHasManager, parameter, orderBy);
&nbsp;        // Fetch all users matching filters, no pagination
<b class="fc">&nbsp;        List&lt;UserEntity&gt; users = userRepository.getUsers(id, email, name, phone,</b>
&nbsp;                accountState, roleStr, office,
&nbsp;                userIsManager, userIsAdmin, userHasManager,
&nbsp;                parameter, orderBy, null, null);
&nbsp;
<b class="fc">&nbsp;        List&lt;UserDTO&gt; userDtos = users.stream()</b>
<b class="fc">&nbsp;                .map(userMapper::toDto)</b>
<b class="fc">&nbsp;                .collect(Collectors.toList());</b>
&nbsp;
&nbsp;       
<b class="fc">&nbsp;            return CSVGenerator.generateUserCSV(userDtos, lang, isAdmin);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            LOGGER.error(&quot;Error generating CSV for users&quot;, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to generate CSV&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Generates an XLSX file of all users matching the given filters and sorting (no pagination).
&nbsp;     *
&nbsp;     * @param id             User ID to filter (optional)
&nbsp;     * @param email          Email to filter (optional)
&nbsp;     * @param name           Name or surname to filter (optional)
&nbsp;     * @param phone          Phone number to filter (optional)
&nbsp;     * @param accountState   Account state to filter (optional)
&nbsp;     * @param roleStr        Role to filter (optional)
&nbsp;     * @param office         Office to filter (optional)
&nbsp;     * @param userIsManager  Manager filter (optional)
&nbsp;     * @param userIsAdmin    Admin filter (optional)
&nbsp;     * @param userHasManager Managed filter (optional)
&nbsp;     * @param lang           Language for header translation
&nbsp;     * @param parameter      Sorting parameter (optional)
&nbsp;     * @param orderBy        Sorting order (ASCENDING or DESCENDING)
&nbsp;     * @param isAdmin        Whether the export is performed by an admin (affects columns)
&nbsp;     * @return XLSX file as byte array
&nbsp;     * @throws RuntimeException if XLSX generation fails
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public byte[] generateUsersXLSX(Long id, String email, String name, String phone,
&nbsp;            AccountState accountState, String roleStr, Office office,
&nbsp;            Boolean userIsManager, Boolean userIsAdmin, Boolean userHasManager, Language lang,
&nbsp;            Parameter parameter, OrderBy orderBy, boolean isAdmin) {
&nbsp;        try {
<b class="fc">&nbsp;            LOGGER.info(&quot;Generating XLSX for users with filters: id={}, email={}, name={}, phone={}, accountState={}, roleStr={}, office={}, userIsManager={}, userIsAdmin={}, userHasManager={}, parameter={}, orderBy={}&quot;,</b>
&nbsp;                    id, email, name, phone, accountState, roleStr, office, userIsManager, userIsAdmin, userHasManager, parameter, orderBy);
&nbsp;            // Fetch all users matching filters, no pagination
<b class="fc">&nbsp;            List&lt;UserEntity&gt; users = userRepository.getUsers(id, email, name, phone,</b>
&nbsp;                    accountState, roleStr, office,
&nbsp;                    userIsManager, userIsAdmin, userHasManager,
&nbsp;                    parameter, orderBy, null, null);
&nbsp;
<b class="fc">&nbsp;            List&lt;UserDTO&gt; userDtos = users.stream()</b>
<b class="fc">&nbsp;                    .map(userMapper::toDto)</b>
<b class="fc">&nbsp;                    .collect(Collectors.toList());</b>
&nbsp;
<b class="fc">&nbsp;            return pt.uc.dei.utils.XLSXGenerator.generateUserXLSX(userDtos, lang, isAdmin);</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            LOGGER.error(&quot;Error generating XLSX for users&quot;, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Failed to generate XLSX&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes temporary user information, removing associated activation tokens.
&nbsp;     *
&nbsp;     * @param userToDelete The temporary user DTO to be deleted.
&nbsp;     * @return {@code true} if deletion was successful, {@code false} otherwise.
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public boolean deleteTemporaryUserInformation(TemporaryUserDTO userToDelete) {
<b class="fc">&nbsp;        TemporaryUserEntity user = temporaryUserRepository.findTemporaryUserByEmail(userToDelete.getEmail());</b>
<b class="fc">&nbsp;        List&lt;ActivationTokenEntity&gt; activationTokens = activationTokenRepository.getTokensOfUser(user);</b>
&nbsp;        // Delete activation tokens
<b class="fc">&nbsp;        for (ActivationTokenEntity activationToken : activationTokens) {</b>
<b class="fc">&nbsp;            activationTokenRepository.remove(activationToken);</b>
&nbsp;        }
<b class="fc">&nbsp;        activationTokenRepository.flush();</b>
&nbsp;        // Delete the temporary user
<b class="fc">&nbsp;        deleteTemporaryUser(userToDelete);</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes a temporary user from the repository.
&nbsp;     *
&nbsp;     * @param userToDelete The temporary user DTO to be removed.
&nbsp;     * @return {@code true} if deletion was successful, {@code false} otherwise.
&nbsp;     */
&nbsp;    private boolean deleteTemporaryUser(TemporaryUserDTO userToDelete) {
&nbsp;        try {
<b class="fc">&nbsp;            TemporaryUserEntity temporaryUser = temporaryUserRepository</b>
<b class="fc">&nbsp;                    .findTemporaryUserByEmail(userToDelete.getEmail());</b>
<b class="fc">&nbsp;            temporaryUserRepository.remove(temporaryUser);</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            LOGGER.error(&quot;Failed to delete temporary user: {}&quot;, userToDelete.getEmail(), e);</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if a user is managed by a specific manager.
&nbsp;     *
&nbsp;     * @param userId    The user ID
&nbsp;     * @param managerId The manager ID
&nbsp;     * @return true if the user is managed by the given manager, false otherwise
&nbsp;     */
&nbsp;    public boolean checkIfManagerOfUser(Long userId, Long managerId) {
<b class="fc">&nbsp;        UserEntity user = userRepository.findUserById(userId);</b>
<b class="pc">&nbsp;        if (user == null) {</b>
<b class="nc">&nbsp;            LOGGER.error(&quot;User with ID {} not found&quot;, userId);</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        UserEntity manager = user.getManagerUser();</b>
<b class="fc">&nbsp;        boolean isManager = manager != null &amp;&amp; manager.getId().equals(managerId);</b>
<b class="fc">&nbsp;        LOGGER.info(&quot;User with ID {} is managed by manager with ID {}: {}&quot;, userId, managerId, isManager);</b>
<b class="fc">&nbsp;        return isManager;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if a user is an admin.
&nbsp;     *
&nbsp;     * @param userId The user ID
&nbsp;     * @return true if the user is an admin, false otherwise
&nbsp;     */
&nbsp;    public boolean checkIfUserIsAdmin(Long userId) {
<b class="fc">&nbsp;        UserEntity user = userRepository.findUserById(userId);</b>
<b class="pc">&nbsp;        if (user == null) {</b>
<b class="nc">&nbsp;            LOGGER.error(&quot;User with ID {} not found&quot;, userId);</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="fc">&nbsp;        boolean isAdmin = user.getUserIsAdmin();</b>
<b class="fc">&nbsp;        LOGGER.info(&quot;User with ID {} is admin: {}&quot;, userId, isAdmin);</b>
<b class="fc">&nbsp;        return isAdmin;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Converts a {@link TemporaryUserEntity} to a {@link TemporaryUserDTO}.
&nbsp;     *
&nbsp;     * @param temporaryUser The temporary user entity.
&nbsp;     * @return A data transfer object representation of the temporary user.
&nbsp;     */
&nbsp;    public TemporaryUserDTO temporaryUserEntityToTemporaryUserDTO(TemporaryUserEntity temporaryUser) {
<b class="fc">&nbsp;        TemporaryUserDTO temporaryUserDTO = new TemporaryUserDTO();</b>
<b class="fc">&nbsp;        temporaryUserDTO.setEmail(temporaryUser.getEmail());</b>
<b class="fc">&nbsp;        temporaryUserDTO.setPassword(temporaryUser.getPassword());</b>
<b class="fc">&nbsp;        temporaryUserDTO.setId(temporaryUser.getId());</b>
<b class="fc">&nbsp;        temporaryUserDTO.setSecretKey(temporaryUser.getSecretKey());</b>
<b class="fc">&nbsp;        return temporaryUserDTO;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks and updates the account state of a user based on profile completeness.
&nbsp;     *
&nbsp;     * @param userId The user ID to check
&nbsp;     * @return true if the account state was updated or already correct, false otherwise
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public boolean checkAndUpdateAccountState(Long userId) {
<b class="fc">&nbsp;        UserEntity user = userRepository.findUserById(userId);</b>
<b class="pc">&nbsp;        if (user == null)</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;
<b class="pc">&nbsp;        boolean isComplete = user.getHasAvatar() &amp;&amp;</b>
<b class="pc">&nbsp;                user.getBiography() != null &amp;&amp;</b>
<b class="pc">&nbsp;                user.getBirthdate() != null &amp;&amp;</b>
<b class="pc">&nbsp;                user.getMunicipality() != null &amp;&amp;</b>
<b class="pc">&nbsp;                user.getName() != null &amp;&amp;</b>
<b class="pc">&nbsp;                user.getPhone() != null &amp;&amp;</b>
<b class="pc">&nbsp;                user.getPostalCode() != null &amp;&amp;</b>
<b class="pc">&nbsp;                user.getStreet() != null &amp;&amp;</b>
<b class="pc">&nbsp;                user.getSurname() != null;</b>
&nbsp;
<b class="pc">&nbsp;        if (isComplete &amp;&amp; user.getAccountState() == AccountState.INCOMPLETE) {</b>
<b class="fc">&nbsp;            user.setAccountState(AccountState.COMPLETE);</b>
<b class="fc">&nbsp;            userRepository.persist(user);</b>
&nbsp;        }
<b class="fc">&nbsp;        LOGGER.info(&quot;User account state updated for user ID: &quot; + userId + &quot;, new state: &quot; + user.getAccountState());</b>
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * Adds a finished course for a user. Throws exceptions if user or course not found, or if already completed.
&nbsp;     * &lt;p&gt;
&nbsp;     * Also sends notification and email to the user and their manager.
&nbsp;     *
&nbsp;     * @param userId   The user ID
&nbsp;     * @param courseId The course ID
&nbsp;     * @return The created FinishedCourseDTO
&nbsp;     * @throws IllegalArgumentException if user or course not found
&nbsp;     * @throws IllegalStateException if the user already has this course as completed
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public FinishedCourseDTO addFinishedCourse(Long userId, Long courseId) {
<b class="nc">&nbsp;        UserEntity user = userRepository.findUserById(userId);</b>
<b class="nc">&nbsp;        if (user == null) {</b>
<b class="nc">&nbsp;            LOGGER.error(&quot;User not found with id: {}&quot;, userId);</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;User not found with id: &quot; + userId);</b>
&nbsp;        }
<b class="nc">&nbsp;        CourseEntity course = courseRepository.findCourseById(courseId);</b>
<b class="nc">&nbsp;        if (course == null) {</b>
<b class="nc">&nbsp;            LOGGER.error(&quot;Course not found with id: {}&quot;, courseId);</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Course not found with id: &quot; + courseId);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (course.getCourseIsActive() == null || !course.getCourseIsActive()) {</b>
<b class="nc">&nbsp;            LOGGER.error(&quot;Course is not active: {}&quot;, courseId);</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Course is no longer active.&quot;);</b>
&nbsp;        }
&nbsp;        // Check if already completed using user&#39;s completed courses
<b class="nc">&nbsp;        if (user.getCompletedCourses() != null &amp;&amp; user.getCompletedCourses().stream().anyMatch(fc -&gt; fc.getCourse() != null &amp;&amp; fc.getCourse().getId().equals(courseId))) {</b>
<b class="nc">&nbsp;            LOGGER.warn(&quot;User {} already has course {} as completed.&quot;, userId, courseId);</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;User already has this course as completed.&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        FinishedCourseEntity finished = new FinishedCourseEntity();</b>
<b class="nc">&nbsp;        finished.setUser(user);</b>
<b class="nc">&nbsp;        finished.setCourse(course);</b>
<b class="nc">&nbsp;        finished.setCompletionDate(LocalDate.now());</b>
<b class="nc">&nbsp;        finishedCourseRepository.persist(finished);</b>
<b class="nc">&nbsp;        String managerName = user.getManager().getName() + &quot; &quot; + user.getManager().getSurname();</b>
<b class="nc">&nbsp;        emailService.sendNewCourseNotificationEmail(user.getEmail(), user.getName(), managerName, course.getTitle(), user.getId());</b>
<b class="nc">&nbsp;        notificationService.newCourseNotification(finished);</b>
<b class="nc">&nbsp;        LOGGER.info(&quot;Added finished course: userId={}, courseId={}, date={}&quot;, userId, courseId, finished.getCompletionDate());</b>
<b class="nc">&nbsp;        return finishedCourseMapper.toDto(finished);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if a user with the given ID still manages any users.
&nbsp;     *
&nbsp;     * @param managerId The manager&#39;s user ID
&nbsp;     * @return true if the user still manages others, false otherwise
&nbsp;     */
&nbsp;    private boolean checkIfUserStillIsManager(Long managerId) {
<b class="nc">&nbsp;        if (userRepository.checkIfUserStillHasManagedUsers(managerId)) {</b>
<b class="nc">&nbsp;            LOGGER.info(&quot;User with ID {} still manages users&quot;, managerId);</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            LOGGER.info(&quot;User with ID {} manages no users&quot;, managerId);</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Updates the manager status of a user to false and persists the change.
&nbsp;     *
&nbsp;     * @param user The user entity to update
&nbsp;     */
&nbsp;    private void updateManagerStatus(UserEntity user) {
<b class="nc">&nbsp;        user.setUserIsManager(false);</b>
<b class="nc">&nbsp;        userRepository.persist(user);</b>
<b class="nc">&nbsp;        LOGGER.info(&quot;User with ID {} is no longer a manager&quot;, user.getId());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Updates admin permissions for a user.
&nbsp;     * &lt;p&gt;
&nbsp;     * Only administrators can use this functionality. Users cannot remove their own admin permissions.
&nbsp;     *
&nbsp;     * @param userId      The ID of the user to update
&nbsp;     * @param isAdmin     The new admin status
&nbsp;     * @param requesterId The ID of the user making the request
&nbsp;     * @return true if update was successful, false otherwise
&nbsp;     */
&nbsp;    @Transactional
&nbsp;    public Boolean updateAdminPermissions(Long userId, boolean isAdmin, Long requesterId) {
&nbsp;        try {
&nbsp;            // Verify requester is admin
<b class="fc">&nbsp;            UserEntity requester = userRepository.findUserById(requesterId);</b>
<b class="pc">&nbsp;            if (requester == null || !requester.getUserIsAdmin()) {</b>
<b class="fc">&nbsp;                LOGGER.error(&quot;Non-admin user {} attempted to modify admin permissions&quot;, requesterId);</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Prevent self-removal of admin permissions
<b class="pc">&nbsp;            if (userId.equals(requesterId) &amp;&amp; !isAdmin) {</b>
<b class="fc">&nbsp;                LOGGER.error(&quot;User {} attempted to remove their own admin permissions&quot;, requesterId);</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;            
<b class="fc">&nbsp;            UserEntity user = userRepository.findUserById(userId);</b>
<b class="fc">&nbsp;            if (user == null) {</b>
<b class="fc">&nbsp;                LOGGER.error(&quot;User not found with ID: {}&quot;, userId);</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;            
<b class="fc">&nbsp;            user.setUserIsAdmin(isAdmin);</b>
<b class="fc">&nbsp;            userRepository.merge(user);</b>
&nbsp;            
<b class="fc">&nbsp;            LOGGER.info(&quot;Admin permissions updated: User {} isAdmin={} by user {}&quot;, userId, isAdmin, requesterId);</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;            
&nbsp;        } catch (Exception e) {
<b class="nc">&nbsp;            LOGGER.error(&quot;Error updating admin permissions for user {}: {}&quot;, userId, e.getMessage());</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-07-15 20:29</div>
</div>
</body>
</html>
